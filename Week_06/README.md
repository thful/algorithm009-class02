## 动态规划(递推) Dynamic Programming
> - 人肉递归低效
> - 找到最近最简方法 面试时的算法题一定是可拆解成重复解决的方法的 不会硬写上百行代码的
> - 数学归纳法思维 寻找重复性-->计算机指令集
> - 动态规划本质上是`分治(Divide&Conquer)`+`最优子结构(Optimal substructure)`[DP常见是求最大值 最小值 最优值等]

### 动态规划与递归与分治的区别
> - `动态规划` 和 `递归` 或 `分治`没有根本上的区别(关键看有无最优的子结构)
> - 共性：找到重复子问题
> - 差异性：最优子结构、中途可以淘汰次优解

### 用DP方式解斐波那契数列
```java
// F[n] = F[n-1] + F[n-2]
public int F(int n) {
    if (n <= 1) return n;
    int[] dp = new int[n + 1];
    dp[1] = 0;
    dp[2] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```

### 用DP方式解不同路径
> - 每个格子只能向下或向右走 求从start到end的可走路径有多少条
> - 每一个格子都是向下向右两个格子的总和
> - 至底向上递推
> - 状态转移方程(DP议程)
```java
opt[i,j]=opt[i+1,j]+opt[i,j+1]
```
> - 完整逻辑
```java
if a[i,j]=='空地' --> opt[i,j]=opt[i+1,j]+opt[i,j+1];
else --> opt[i,j]=0;
```

### 动态规划关键点
> - 最优子结构:`opt[n]=best_of(opt[n-1],opt[n-2],...)`(有时间是简单的累加 有时候是最大值或最小值)
> - 储存中间状态:`opt[i]`
> - 递推公式(状态转移方程/DP方程)
>  - Fib:`opt[i]=opt[n-1]+opt[n-2]`
>  - 二维路径:`opt[i,j]=opt[i+j][j]+opt[i][j+1](且判断a[i,j]是否空地)`

### 动态规划小结
> - 打破自己的思维惯性 形成机器思维
> - 理解复杂逻辑的关键
> - 也是职业进阶的要点要领