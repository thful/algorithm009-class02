## 高级动态规划
### 递归、分治、动态规划复习
> - 递归：函数调用自身
> - 分治：分而治之 通常需要使用递归实现 `也可以用迭代强制实现 也算是分治`
> - 动态规划：适合有重复子问题的情况 其思想为分治加上最优子结构 通常使用顺推形式进行动态递推
> - 共性：找到重复子问题
> - 差异性：最优子结构、中途可以淘汰次优解

### 进阶版动态规划
> - 动态规划问题的复杂度来源是状态定义和状态转移方程
>   - 状态拥有更多维度（二维、三维或者更多 甚至需要压缩）
>   - 状态转移方程更加复杂

### 算法的本质
> - 内功
> - 逻辑思维
> - 数学 `高级竞赛题目以动态规划为主 主要还是在考数字功底`

### 作业：写出不同路径 II 的状态转移方程
> - 创建二维数组`dp[i][j]` 表示从左上角到右下角的`[i][j]`不同路径数

> - 由于只能向下或右 所以数组的`[i]`从左到右遍历第`i`行 结果为`1无障碍物` `0从这个位置向右全部为0`
> - 从上向下遍历第`j`行 结果为`1无障碍物` `0从这个位置向下全部为0`
> - 当`i>0 & j>0` 判断`(i,j)`是否是障碍物
>   - 如果是障碍物 `dp[i][j]=0`
>   - 如果不是障碍物 可以是`[i-1][j] 下移到达` 也可以是`[i][j-1]右移到达` 
>   - 所以 `dp[][] = dp[i-1][j]+dp[i][j-1]`

> - 如果 `[i][j]==1` 则 `dp[i][j] = 0`
> - 如果 `[i][j]==0` 则 `dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`

> - 结果为 dp[m - 1][n - 1]

## 字符串算法

### 字符串基础知识
> - 在Java和Python中 字符串是不可变的
> - 在Java中字符串是引用类型 因此==比较两个字符串的引用是否相同而不是判断字符串内容是否相等 需要通过equals或equalsIgnoreCase判断字符串内容是否相等

### 字符串匹配算法
> - 字符串匹配算法用于匹配模式在字符串中第一次出现的位置 其中字符串的长度是m 模式的长度是n 满足m>n
> - 暴力法的时间复杂度是O(mn)
> - Rabin-Karp算法基于哈希实现 平均时间复杂度是O(m+n)
> - Knuth-Morris-Pratt算法利用最大前缀信息 减少不必要的比较次数 时间复杂度是O(m+n)