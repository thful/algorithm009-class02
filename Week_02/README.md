# 哈希[散列]表

> - 哈希表`Hash table`也叫散列表 是根据关键码值`Key Value`而直接进行访问的数据结构
> - 它通过把关键码值映射到表中的一个位置来访问记录 以加快查找的速度
> - 这个映射函数叫作散列函数`Hash Function` 存信记录的数组叫做哈希表[散列表]

## 现实中应用场景
> - 电话号码簿
> - 用户信息表
> - 缓存`LRU Cache`
> - 键值对存储`Redis`


## 哈希函数`Hash Function`
> - 把要存储的东西放入哈希函数中取模
> - 得到一个整数下标
 
## 哈希碰撞`Hash Collisions`
> - 不同的要存储的数据 如果经过哈希函数之后发现下标重复了 这就叫做哈希碰撞
> - 这时一般的处理方法 就会把两个数据都存储到这个下标中 把两个值以链表的形式放到同一个下标中
> - 查询哈希下标的操作是O(1) 但要找到具体的值可能就远远不是O(1)了
> - 所以好的哈希算法中 会尽可能的降低哈希碰撞的机率

## 时间复杂度
> - 查询 插入 删除大部分情况下都是O(1)的
> - 但如果哈希函数选用的不好造成了大量的哈希碰撞 就会退化成链表的形式

## 集合与映射
> - 集合 Set -> `Key不重复的单列集合`
>  - HashSet -> 本质就是用了一个`HaspMap`来实现的
>    - `Key`正常存
>    - `Value`存了一个`Object`占位
>    - 所以对外只体现一个`Key`

> - 映射/字典 Map -> `Key和Value均不重复的双列集合`
>  - HashTable
>    - 线程安全 效率低 `Key`与`Value`均不允许NULL
>  - HashMap
>    - 线程不安全 效率高 `Key`与`Value`均允许NULL 是为了替代`Hashtable`而生
--------------------
# 二叉树 Binary Tree
> - 如果链表有多个`Next`指针 那么`链表`就变成了`树` 这是一种底层为链表的全新数据结构
> - `链表升维`就变成了`树`
> - `有环的树`就变成了`图`
> - 二叉树是使用最广泛的一种树

## 二叉树的遍历
> - 因为树的遍历用循环特别麻烦 因为每一层循环的特别都是一样的 所以树的面试题解法一般都是递归
> - 前序遍历 Pre-order : 根-左-右
> - 中序遍历 In-order ：左-根-右
> - 后序遍历 Post-order 左-右-根


## 二叉搜索树 Binary Search Tree
> - `二叉搜索树` 也称`二叉排序树`、`有序二叉树[Ordered Binary Tree]`、`排序二叉树[Sorted Binary Tree]` 是指一棵空树或具有以下性质的二叉树
> - 左子树上`所有结点`的值均小于它的根结点的值
> - 右子树上`所有结点`的值均大于它的根结点的值
> - 以此类推：左、右子树也分别为二叉查找树[这就是重复性]
> - 二叉搜索树的遍历是`中序编历：升序排列`

### 二叉搜索树时间复杂度
> - 因为每次都能过滤掉一半的节点 所以
>  - 查询 O(logn)
>  - 插入 O(logn)
>  - 删除 O(logn)
> - 如果一根`二叉搜索树`只有左节点或只有右节点 就会退化成`链表`了 这时如果再进行操作就会回归到`链表` `O(n)`的时间复杂度
> - 为了解决这种情况 所以有一个新的概念叫`二叉平衡树`

----------------

## 堆 Heap
> - 堆通常都是一棵完全树 树型的数据结构
> - 可以迅速找到一堆数中的最大或者最小值的数据结构
> - 根节点最大的堆叫做大顶堆或大根堆
> - 根节点最小的堆叫做小顶堆或小根堆
> - 常见的堆有`二叉堆[面试常用]` `斐波那契堆[工业级多叉树实现]`
> - Heap本身就是一个接口 就定义了几种方法 可以有无数种实现方法
![](index_files/feb4312c-f0f7-4406-8441-9d2fa2af9675.jpg)
> - 二叉堆只是一个堆的实现 要么找最大值`大顶堆` 要么找最小值`小顶堆` 不可两者兼容

## 二叉堆 Binary Heap
### 堆的时间复杂度
> - `小顶堆`
>  - find-min:O(1)
>  - delete-min:O(logn)
> - `大顶堆`
>  - find-max:O(1)
>  - delete-max:O(logn)
> - insert(create):`二叉堆O(logn)` or `斐波那契堆O(1)`

### 二叉堆性质
> - 二叉堆通过完全二叉树来实现
> - `大顶堆` 它必须满足下列性质：
>   - 是一棵完全树
>   - 树中任意节点的值总是`>=`其儿子节点的值
>   - 根节点一定是`最大`的节点
> - `小顶堆` 它必须满足下列性质：
>   - 是一棵完全树
>   - 树中任意节点的值总是`<=`其儿子节点的值
>   - 根节点一定是`最小`的节点

### 二叉堆的实现细节
> - 二叉堆一般都通过`一维数组`实现
> - 假设`第一个元素(顶堆元素)`在数组中的索引为0的话 则父节点和子节点的位置关系如下
>  - 索引为i的左孩子的索引是`2*i+1`
>  - 索引为i的右孩子的索引是`2*i+2`
>  - 索引为i的父节点的索引是`floor((i-1)/2)`

#### 插入元素
> - O(logn)
> - 新元素一律先插入到堆的尾部
> - 依次向上调整整个堆的结构 `每次对父节点对比 一直到根即可`

#### 删除操作 Delete Max 
> - O(logn)
> - 删除顶部 再将堆尾元素替换到顶部
> - 依次从根部向下调整整个堆的结构 `每次和两个子节点对比 一直到根即可`

--------------

## 图 Graph
> - 不管在面试还是工作中 现在遇到的图的算法与运用越来越少 很少用 也很少面试
> - 图的本质是：有点有边

### 图的属性 Graph(V,E)
> - V-vertex：点
>   - 1.度-入度和出度
>   - 2.点与点之间：连通与否
> - E-edge：边
>   - 1.有向和无向(双行线和单行线)
>   - 2.权重(边长)


## 四种图的形式
> - 有向图和无向图
>   - 如果图中的边没有方向 可以从任意一边到达另一边 则称为无向图
>   - 就像双向公路 A地点到B地点可以从A开车到B 也可以从B开车到A
>   - 但如果只能从A地点到B地点 反而不行的话就叫做有向图

> - 有权图和无权图
>   - 图中的边如果有一个权值(数字) 它代码两个点的距离 这就做叫有权图
>   - 如果边没有权值的话 就称为无权图

>   - 无向无权图
>   - 有向无权图
>   - 无向有权图
>   - 有向有权图

## 图的继续深入学习
> - 连通图个数： https://leetcode-cn.com/problems/number-of-islands/
> - 拓扑排序（Topological Sorting）： https://zhuanlan.zhihu.com/p/34871092
> - 最短路径（Shortest Path）：Dijkstra https://www.bilibili.com/video/av25829980?from=search&seid=13391343514095937158
> - 最小生成树（Minimum Spanning Tree）： https://www.bilibili.com/video/av84820276?from=search&seid=17476598104352152051

